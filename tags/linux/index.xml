<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on YJ Blog</title><link>https://blog.younjinjeong.io/tags/linux/</link><description>Recent content in linux on YJ Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 16 Apr 2021 15:04:51 +0800</lastBuildDate><atom:link href="https://blog.younjinjeong.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>errno(3) - Linux manual page</title><link>https://blog.younjinjeong.io/posts/translate/manpage/errno/</link><pubDate>Fri, 16 Apr 2021 15:04:51 +0800</pubDate><guid>https://blog.younjinjeong.io/posts/translate/manpage/errno/</guid><description>원문 링크 errno(3) - Linux manual page
이름 errno - 마지막 에러 번호(number)
시놉시스 #include &amp;lt;errno.h&amp;gt;세부설명 &amp;lt;errno.h&amp;gt; 헤더 파일에는 시스템콜이나 일부 라이브러리 함수 동작에 문제가 있을때 무엇이 잘못되었는지를 나타내는 정수 타입의 errno 변수가 선언되어 있다.
errno errno 변수의 값은 호출이 에러를 리턴한 경우에만 중요하다. (예로, 대부분의 시스템콜은 -1을, 대부분의 라이브러리 함수에서는 NULL이나 -1을 리턴한다); 성공한 함수에게는 errno의 값 변경이 허락된다. 모든 시스템콜 및 라이브러리 함수는 errno 값을 0으로 설정할 수 없다.</description></item><item><title>syscalls(2) - Linux manual page</title><link>https://blog.younjinjeong.io/posts/translate/manpage/syscalls/</link><pubDate>Thu, 15 Apr 2021 21:53:19 +0800</pubDate><guid>https://blog.younjinjeong.io/posts/translate/manpage/syscalls/</guid><description>심심하니까 시리즈 번역물을 만들어 보기로 한다. 또하나의 장기 프로젝트 - 리눅스 매뉴얼 페이지, MAN
원문 링크 syscalls(2) - Linux manual page
번역 이름 syscalls - Linux system calls
시놉시스 Linux system calls
설명 시스템콜이라 함은 리눅스 커널과 애플리케이션 사이의 기반 인터페이스를 의미한다.
시스템콜과 라이브러리 래퍼(wrapper) 함수 애플리케이션에서 시스템콜을 직접 호출하는 경우는 많지않다. 대신 glibc(또는 다른 라이브러리)에 내장된 래퍼 함수를 통해 호출된다. 시스템콜을 직접 호출하는 방법에 대해 알고 싶다면, 다음을 참조하자. 항상은 아니지만 대부분의 경우, 라이브러리에 내장된 래퍼 함수의 이름은 호출하고자 하는 시스템콜의 이름과 동일하다.</description></item><item><title>NAPI on Linux</title><link>https://blog.younjinjeong.io/posts/tech/napi/</link><pubDate>Sat, 06 Mar 2021 01:37:04 +0800</pubDate><guid>https://blog.younjinjeong.io/posts/tech/napi/</guid><description>이제는 오래되어 버린 기술이지만, 2006년 경의 2.6.1x 대 커널에서의 NAPI 사용으로 인한 시스템 부하 절감 및 네트워킹 성능 향상은 경이로운 것이었다. 무지막지한 인터럽트 증가로 인하여 static 파일을 서비스 하는 웹 서버가 죽을똥 살똥 하던 모습이란.
언젠가 한번은 적어야지 했는데, 마치 Memory Hole 관련 문제처럼 언젠가는 잊어버리지 않을까 싶어, 생각 난 김에 포스팅 한다. 오랜만에 보는 HOW-To 문서를 번역할 예정이며, 요새 커널 버전과는 매우 동떨어져 있지만.. 뭐 그래도 잘 설명 되었으니까. 문서 원본은 아래의 링크에서 참조 할수있다.</description></item></channel></rss>