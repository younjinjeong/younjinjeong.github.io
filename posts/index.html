<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>YJ Blog/posts/</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/terminal-0.7.1.min.css><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/animate-3.7.2.min.css><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/console.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link href=https://blog.younjinjeong.io/posts/index.xml rel=alternate type=application/rss+xml title="YJ Blog"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.younjinjeong.io/posts/"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script async src="https://www.googletagmanager.com/gtag/js?id=G-LF5W12M5RW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LF5W12M5RW",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/xterm.css><script type=text/javascript src=https://blog.younjinjeong.io/hugo-theme-console/js/lib/jquery-3.1.1.slim.js></script><body class=terminal><div class=container><h1><a href=https://blog.younjinjeong.io/>Distribution Complete blog</a></h1><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt"><a href=https://blog.younjinjeong.io/ class=no-style>YJ Blog</a>:~#
<a href=https://blog.younjinjeong.io/posts>posts</a>/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"></ul></nav></div></div></body></head><body class=terminal><div class=container></div><div class=container><h1>Posts</h1><br><div class=posts-list><div class=post><p><div class=date>Apr. 16, 2021</div><h1><a href=https://blog.younjinjeong.io/posts/translate/manpage/errno/ title="errno(3) - Linux manual page">errno(3) - Linux manual page</a></h1>원문 링크 errno(3) - Linux manual page
이름 errno - 마지막 에러 번호(number)
시놉시스 #include &lt;errno.h>세부설명 &lt;errno.h> 헤더 파일에는 시스템콜이나 일부 라이브러리 함수 동작에 문제가 있을때 무엇이 잘못되었는지를 나타내는 정수 타입의 errno 변수가 선언되어 있다.
errno errno 변수의 값은 호출이 에러를 리턴한 경우에만 중요하다. (예로, 대부분의 시스템콜은 -1을, 대부분의 라이브러리 함수에서는 NULL이나 -1을 리턴한다); 성공한 함수에게는 errno의 값 변경이 허락된다. 모든 시스템콜 및 라이브러리 함수는 errno 값을 0으로 설정할 수 없다.</p></div><div class=post><p><div class=date>Apr. 15, 2021</div><h1><a href=https://blog.younjinjeong.io/posts/translate/manpage/syscalls/ title="syscalls(2) - Linux manual page">syscalls(2) - Linux manual page</a></h1>심심하니까 시리즈 번역물을 만들어 보기로 한다. 또하나의 장기 프로젝트 - 리눅스 매뉴얼 페이지, MAN
원문 링크 syscalls(2) - Linux manual page
번역 이름 syscalls - Linux system calls
시놉시스 Linux system calls
설명 시스템콜이라 함은 리눅스 커널과 애플리케이션 사이의 기반 인터페이스를 의미한다.
시스템콜과 라이브러리 래퍼(wrapper) 함수 애플리케이션에서 시스템콜을 직접 호출하는 경우는 많지않다. 대신 glibc(또는 다른 라이브러리)에 내장된 래퍼 함수를 통해 호출된다. 시스템콜을 직접 호출하는 방법에 대해 알고 싶다면, 다음을 참조하자. 항상은 아니지만 대부분의 경우, 라이브러리에 내장된 래퍼 함수의 이름은 호출하고자 하는 시스템콜의 이름과 동일하다.</p></div><div class=post><p><div class=date>Apr. 15, 2021</div><h1><a href=https://blog.younjinjeong.io/posts/k-pop/hahyunwoo/ title="Dive deep to K-pop Singers #1">Dive deep to K-pop Singers #1</a></h1>While I listen to my favorite Korean music today, I made up my mind to write a Korean pop post. Many famous k-pop stars and artists are out there, but I thought it would be good to introduce non-famous but great singers.
Today, the singer is HA Hyun Woo, who&rsquo;s a frontman of Guckkasten band in Korea. In the band, his role is a leader, vocal, and guitar.
One of the greatest songs he sang, &ldquo;Don&rsquo;t Cry&rdquo; in the show &ldquo;King of Mask Singer&rdquo;.</p></div><div class=post><p><div class=date>Mar. 7, 2021</div><h1><a href=https://blog.younjinjeong.io/posts/translate/phrack-magazine/vol7-issue51-fd-hijacking/ title="Phrack magazine Vol7 Issue51 File Descriptor Hijacking">Phrack magazine Vol7 Issue51 File Descriptor Hijacking</a></h1>블로그 테스트용으로 올려보는 예전 번역 10년전 KHDP에서 번역했었던
File descriptor hijacking 에 대한 글이 생각나
구글링을 해 보았더니, 수정없이 그냥들 보고 있는게 많더라.
사실, FD Hijacking 정도 볼 것 같으면
고딩의 저 어설픈 번역을 수정 할 법도 한데 그냥들 보고 있다는 말이지 홀홀..
10년이 지난 지금, 아직도 저런 공격방법이 통할 지는 모르겠지만
그 시절, 열정만을 가지고 밤새워 번역하고 코드 테스트도 해보며
이땅에 리눅스 및 BSD가 창궐하기전 홀로 즐겼던 세상으로 다시 돌아가 본다.</p></div><div class=post><p><div class=date>Mar. 6, 2021</div><h1><a href=https://blog.younjinjeong.io/posts/tech/napi/ title="NAPI on Linux">NAPI on Linux</a></h1>이제는 오래되어 버린 기술이지만, 2006년 경의 2.6.1x 대 커널에서의 NAPI 사용으로 인한 시스템 부하 절감 및 네트워킹 성능 향상은 경이로운 것이었다. 무지막지한 인터럽트 증가로 인하여 static 파일을 서비스 하는 웹 서버가 죽을똥 살똥 하던 모습이란.
언젠가 한번은 적어야지 했는데, 마치 Memory Hole 관련 문제처럼 언젠가는 잊어버리지 않을까 싶어, 생각 난 김에 포스팅 한다. 오랜만에 보는 HOW-To 문서를 번역할 예정이며, 요새 커널 버전과는 매우 동떨어져 있지만.. 뭐 그래도 잘 설명 되었으니까. 문서 원본은 아래의 링크에서 참조 할수있다.</p></div></div><div class=footer></div><a href=about/>About this blog</a><br>Younjin JEONG: <a href="mailto: younjin.jeong@gmail.com">younjin.jeong@gmail.com</a><br>Powered by <a href=https://gohugo.io/>Hugo</a> with
<a href=https://github.com/mrmierzejewski/hugo-theme-console/>Console Theme</a>.<br><a href=https://opensource.org/licenses/LGPL-3.0>Terms and Conditions</a></br></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-LF5W12M5RW"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LF5W12M5RW")</script></div></body></html>