<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>YJ Blog/posts/translate/manpage/errno/</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/terminal-0.7.1.min.css><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/animate-3.7.2.min.css><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/console.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><meta property="og:title" content="errno(3) - Linux manual page"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://blog.younjinjeong.io/posts/translate/manpage/errno/"><meta property="article:published_time" content="2021-04-16T15:04:51+08:00"><meta name=twitter:title content="errno(3) - Linux manual page"><meta name=twitter:description content="원문 링크 errno(3) - Linux manual page
이름 errno - 마지막 에러 번호(number)
시놉시스 #include <errno.h>세부설명 <errno.h> 헤더 파일에는 시스템콜이나 일부 라이브러리 함수 동작에 문제가 있을때 무엇이 잘못되었는지를 나타내는 정수 타입의 errno 변수가 선언되어 있다.
errno errno 변수의 값은 호출이 에러를 리턴한 경우에만 중요하다. (예로, 대부분의 시스템콜은 -1을, 대부분의 라이브러리 함수에서는 NULL이나 -1을 리턴한다); 성공한 함수에게는 errno의 값 변경이 허락된다. 모든 시스템콜 및 라이브러리 함수는 errno 값을 0으로 설정할 수 없다."><script async src="https://www.googletagmanager.com/gtag/js?id=G-LF5W12M5RW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LF5W12M5RW",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://blog.younjinjeong.io/hugo-theme-console/css/xterm.css><script type=text/javascript src=https://blog.younjinjeong.io/hugo-theme-console/js/lib/jquery-3.1.1.slim.js></script><body class=terminal><div class=container><h1><a href=https://blog.younjinjeong.io/>Distribution Complete blog</a></h1><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt"><a href=https://blog.younjinjeong.io/ class=no-style>YJ Blog</a>:~#
<a href=https://blog.younjinjeong.io/posts>posts</a>/<a href=https://blog.younjinjeong.io/posts/translate>translate</a>/<a href=https://blog.younjinjeong.io/posts/translate/manpage>manpage</a>/<a href=https://blog.younjinjeong.io/posts/translate/manpage/errno>errno</a>/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"></ul></nav></div></div></body></head><body class=terminal><div class=container></div><div class=container><h1>errno(3) - Linux manual page</h1>Apr. 16, 2021<br><br><h1 id=원문-링크>원문 링크</h1><p><a href=https://man7.org/linux/man-pages/man3/errno.3.html>errno(3) - Linux manual page</a></p><h2 id=이름>이름</h2><p>errno - 마지막 에러 번호(number)</p><h2 id=시놉시스>시놉시스</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span></span></span></code></pre></div><h2 id=세부설명>세부설명</h2><p>&lt;errno.h> 헤더 파일에는 시스템콜이나 일부 라이브러리 함수 동작에 문제가 있을때 무엇이 잘못되었는지를 나타내는 정수 타입의 <em>errno</em> 변수가 선언되어 있다.</p><h3 id=errno>errno</h3><p><em>errno</em> 변수의 값은 호출이 에러를 리턴한 경우에만 중요하다. (예로, 대부분의 시스템콜은 -1을, 대부분의 라이브러리 함수에서는 NULL이나 -1을 리턴한다); 성공한 함수에게는 <em>errno</em>의 값 변경이 허락된다. 모든 시스템콜 및 라이브러리 함수는 <em>errno</em> 값을 0으로 설정할 수 없다.</p><p>일부 시스템콜 또는 라이브러리 함수는 (예 <a href=https://man7.org/linux/man-pages/man2/getpriority.2.html>getpriority(2)</a>) 정상적으로 수행되었을때 -1을 리턴하기도 한다. 이러한 경우, 호출을 수행하기 전에 <em>errno</em> 값을 0으로 설정한 후 만약 해당 호출에 에러가 발생한 경우에는 <em>errno</em>의 값이 0인지 아닌지를 확인하는 방법으로 호출의 성공여부를 파악할 수 있다.</p><p><em>errno</em>는 변경 가능한 <em>int</em> 타입의 lvalue로서 ISO C표준으로 정의되어 있으며, 절대 명시적으로 선언해서는 안된다. <em>errno</em>는 또한 매크로(macro)일 수도 있다. <em>errno</em>는 스레드-로컬, 즉 하나의 스레드에서 설정된 값은 다른 스레드에 의해 영향을 받지 않는다.</p><h3 id=에러-번호와-에러-이름>에러 번호와 에러 이름</h3><p>유효환 에러 번호는 모두 양수이다. &lt;errno.h> 헤더 파일에서는 <em>errno</em>의 값이 될 수 있는 양수로 되어있는 각각의 에러 번호에 상징적 이름을 부여하고 있다.</p><p>모든 에러의 이름은 POSIX.1에 정의되어 있으며, 각각의 에러는 <em>EAGAIN</em>과 <em>EWOULDBLOCK</em> 를 제외한 반드시 고유한 값을 가져야 한다. 리눅스에서는 이 두개는 모든 아키텍처에서 동일한 값을 가진다.</p><p>에러 번호는 매우 광범위한 UNIX 시스템과 리눅스가 지원하는 다양한 아키텍처에서 넓게 사용되는 상징적 이름과 매칭된다. 따라서 특정 에러 이름에 대흥하는 번호는 아래에 표에 별도로 명시하지 않았다. <a href=https://man7.org/linux/man-pages/man3/perror.3.html>perror(3)</a>와 <a href=https://man7.org/linux/man-pages/man3/strerror.3.html>strerror(3)</a> 함수들은 에러 이름들을 사람이 이해 가능한 에러 메세지로 변환하는데 사용된다.</p><p>리눅스 시스템에서는 아래에 나열된 모든 심볼릭 에러 리스트를 전부 제공할 가능성이 있으며 에러 이름과 그에 상응하는 에러 번호를 <em>errno(1)</em> 명령어를 사용하여 조회가 가능하다. (<em>errno</em> 명령어는 <em>moreutils</em> 패키지에 포함되어 있다)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ errno -l 
</span></span><span style=display:flex><span>EPERM <span style=color:#ae81ff>1</span> Operation not permitted
</span></span><span style=display:flex><span>ENOENT <span style=color:#ae81ff>2</span> No such file or directory
</span></span><span style=display:flex><span>ESRCH <span style=color:#ae81ff>3</span> No such process
</span></span><span style=display:flex><span>EINTR <span style=color:#ae81ff>4</span> Interrupted system call
</span></span><span style=display:flex><span>EIO <span style=color:#ae81ff>5</span> Input/output error
</span></span></code></pre></div><p><em>errno(1)</em> 명령어는 특정 에러 번호와 이름을 검색하는데 사용할 수도 있으며, 이를 통해 해당 에러에 대한 설명도 함께 조회할 수 있다. 아래의 예제를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>$ errno <span style=color:#ae81ff>2</span> 
</span></span><span style=display:flex><span>ENOENT <span style=color:#ae81ff>2</span> No such file or directory 
</span></span><span style=display:flex><span>$ errno ESRCH 
</span></span><span style=display:flex><span>ESRCH <span style=color:#ae81ff>3</span> No such process 
</span></span><span style=display:flex><span>$ errno -s permission 
</span></span><span style=display:flex><span>EACCES <span style=color:#ae81ff>13</span> Permission denied 
</span></span></code></pre></div><h3 id=에러-이름-리스트>에러 이름 리스트</h3><p>아래 리스트의 에러를 나타내는 심볼릭 이름들은 아래의 표시를 따른다.</p><ul><li>POSIX.1-2001: POSIX.1-2001에서 정의된 이름 및 그 이후의 POSIX.1 버전에서 정의된 이름. (별도의 명시가 없는한)</li><li>POSIX.1-2008: POSIX.1 표준 이전에 정의된 이름을 제외한 POSIX.1-2008에서 정의된 이름</li><li>C99: C99에 의해 정의된 이름</li></ul><p>아래는 리눅스에서 정의된 심볼릭 에러 이름의 리스트:</p><p><em>E2BIG</em> Argument list too long (POSIX.1-2001)</p><p>EACCES Permission denied (POSIX.1-2001).</p><p>EADDRINUSE
Address already in use (POSIX.1-2001).</p><p>EADDRNOTAVAIL
Address not available (POSIX.1-2001).</p><p>EAFNOSUPPORT
Address family not supported (POSIX.1-2001).</p><p>EAGAIN Resource temporarily unavailable (may be the same value as EWOULDBLOCK) (POSIX.1-2001).</p><p>EALREADY
Connection already in progress (POSIX.1-2001).</p><p>EBADE Invalid exchange.</p><p>EBADF Bad file descriptor (POSIX.1-2001).</p><p>EBADFD File descriptor in bad state.</p><p>EBADMSG
Bad message (POSIX.1-2001).</p><p>EBADR Invalid request descriptor.</p><p>EBADRQC
Invalid request code.</p><p>EBADSLT
Invalid slot.</p><p>EBUSY Device or resource busy (POSIX.1-2001).</p><p>ECANCELED
Operation canceled (POSIX.1-2001).</p><p>ECHILD No child processes (POSIX.1-2001).</p><p>ECHRNG Channel number out of range.</p><p>ECOMM Communication error on send.</p><p>ECONNABORTED
Connection aborted (POSIX.1-2001).</p><p>ECONNREFUSED
Connection refused (POSIX.1-2001).</p><p>ECONNRESET
Connection reset (POSIX.1-2001).</p><p>EDEADLK
Resource deadlock avoided (POSIX.1-2001).</p><p>EDEADLOCK
On most architectures, a synonym for EDEADLK. On some
architectures (e.g., Linux MIPS, PowerPC, SPARC), it is a
separate error code &ldquo;File locking deadlock error&rdquo;.</p><p>EDESTADDRREQ
Destination address required (POSIX.1-2001).</p><p>EDOM Mathematics argument out of domain of function (POSIX.1,
C99).</p><p>EDQUOT Disk quota exceeded (POSIX.1-2001).</p><p>EEXIST File exists (POSIX.1-2001).</p><p>EFAULT Bad address (POSIX.1-2001).</p><p>EFBIG File too large (POSIX.1-2001).</p><p>EHOSTDOWN
Host is down.</p><p>EHOSTUNREACH
Host is unreachable (POSIX.1-2001).</p><p>EHWPOISON
Memory page has hardware error.</p><p>EIDRM Identifier removed (POSIX.1-2001).</p><p>EILSEQ Invalid or incomplete multibyte or wide character (POSIX.1, C99).<br>The text shown here is the glibc error description; in
POSIX.1, this error is described as &ldquo;Illegal byte
sequence&rdquo;.</p><p>EINPROGRESS
Operation in progress (POSIX.1-2001).</p><p>EINTR Interrupted function call (POSIX.1-2001); see signal(7).</p><p>EINVAL Invalid argument (POSIX.1-2001).</p><p>EIO Input/output error (POSIX.1-2001).</p><p>EISCONN
Socket is connected (POSIX.1-2001).</p><p>EISDIR Is a directory (POSIX.1-2001).</p><p>EISNAM Is a named type file.</p><p>EKEYEXPIRED
Key has expired.</p><p>EKEYREJECTED
Key was rejected by service.</p><p>EKEYREVOKED
Key has been revoked.</p><p>EL2HLT Level 2 halted.</p><p>EL2NSYNC
Level 2 not synchronized.</p><p>EL3HLT Level 3 halted.</p><p>EL3RST Level 3 reset.</p><p>ELIBACC
Cannot access a needed shared library.</p><p>ELIBBAD
Accessing a corrupted shared library.</p><p>ELIBMAX
Attempting to link in too many shared libraries.</p><p>ELIBSCN
.lib section in a.out corrupted</p><p>ELIBEXEC
Cannot exec a shared library directly.</p><p>ELNRANGE
Link number out of range.</p><p>ELOOP Too many levels of symbolic links (POSIX.1-2001).</p><p>EMEDIUMTYPE
Wrong medium type.</p><p>EMFILE Too many open files (POSIX.1-2001). Commonly caused by
exceeding the RLIMIT_NOFILE resource limit described in
getrlimit(2). Can also be caused by exceeding the limit
specified in /proc/sys/fs/nr_open.</p><p>EMLINK Too many links (POSIX.1-2001).</p><p>EMSGSIZE
Message too long (POSIX.1-2001).</p><p>EMULTIHOP
Multihop attempted (POSIX.1-2001).</p><p>ENAMETOOLONG
Filename too long (POSIX.1-2001).</p><p>ENETDOWN
Network is down (POSIX.1-2001).</p><p>ENETRESET
Connection aborted by network (POSIX.1-2001).</p><p>ENETUNREACH
Network unreachable (POSIX.1-2001).</p><p>ENFILE Too many open files in system (POSIX.1-2001). On Linux,
this is probably a result of encountering the
/proc/sys/fs/file-max limit (see proc(5)).</p><p>ENOANO No anode.</p><p>ENOBUFS
No buffer space available (POSIX.1 (XSI STREAMS option)).</p><p>ENODATA
No message is available on the STREAM head read queue
(POSIX.1-2001).</p><p>ENODEV No such device (POSIX.1-2001).</p><p>ENOENT No such file or directory (POSIX.1-2001).<br>Typically, this error results when a specified pathname
does not exist, or one of the components in the directory
prefix of a pathname does not exist, or the specified
pathname is a dangling symbolic link.</p><p>ENOEXEC
Exec format error (POSIX.1-2001).</p><p>ENOKEY Required key not available.</p><p>ENOLCK No locks available (POSIX.1-2001).</p><p>ENOLINK
Link has been severed (POSIX.1-2001).</p><p>ENOMEDIUM
No medium found.</p><p>ENOMEM Not enough space/cannot allocate memory (POSIX.1-2001).</p><p>ENOMSG No message of the desired type (POSIX.1-2001).</p><p>ENONET Machine is not on the network.</p><p>ENOPKG Package not installed.</p><p>ENOPROTOOPT
Protocol not available (POSIX.1-2001).</p><p>ENOSPC No space left on device (POSIX.1-2001).</p><p>ENOSR No STREAM resources (POSIX.1 (XSI STREAMS option)).</p><p>ENOSTR Not a STREAM (POSIX.1 (XSI STREAMS option)).</p><p>ENOSYS Function not implemented (POSIX.1-2001).</p><p>ENOTBLK
Block device required.</p><p>ENOTCONN
The socket is not connected (POSIX.1-2001).</p><p>ENOTDIR
Not a directory (POSIX.1-2001).</p><p>ENOTEMPTY
Directory not empty (POSIX.1-2001).</p><p>ENOTRECOVERABLE
State not recoverable (POSIX.1-2008).</p><p>ENOTSOCK
Not a socket (POSIX.1-2001).</p><p>ENOTSUP
Operation not supported (POSIX.1-2001).</p><p>ENOTTY Inappropriate I/O control operation (POSIX.1-2001).</p><p>ENOTUNIQ
Name not unique on network.</p><p>ENXIO No such device or address (POSIX.1-2001).</p><p>EOPNOTSUPP
Operation not supported on socket (POSIX.1-2001).<br>(ENOTSUP and EOPNOTSUPP have the same value on Linux, but
according to POSIX.1 these error values should be
distinct.)</p><p>EOVERFLOW Value too large to be stored in data type (POSIX.1-2001).</p><p>EOWNERDEAD Owner died (POSIX.1-2008).</p><p>EPERM Operation not permitted (POSIX.1-2001).</p><p>EPFNOSUPPORT Protocol family not supported.</p><p>EPIPE Broken pipe (POSIX.1-2001).</p><p>EPROTO Protocol error (POSIX.1-2001).</p><p>EPROTONOSUPPORT
Protocol not supported (POSIX.1-2001).</p><p>EPROTOTYPE
Protocol wrong type for socket (POSIX.1-2001).</p><p>ERANGE Result too large (POSIX.1, C99).</p><p>EREMCHG
Remote address changed.</p><p>EREMOTE
Object is remote.</p><p>EREMOTEIO
Remote I/O error.</p><p>ERESTART
Interrupted system call should be restarted.</p><p>ERFKILL
Operation not possible due to RF-kill.</p><p>EROFS Read-only filesystem (POSIX.1-2001).</p><p>ESHUTDOWN
Cannot send after transport endpoint shutdown.</p><p>ESPIPE Invalid seek (POSIX.1-2001).</p><p>ESOCKTNOSUPPORT
Socket type not supported.</p><p>ESRCH No such process (POSIX.1-2001).</p><p>ESTALE Stale file handle (POSIX.1-2001).<br>This error can occur for NFS and for other filesystems.</p><p>ESTRPIPE
Streams pipe error.</p><p>ETIME Timer expired (POSIX.1 (XSI STREAMS option)).<br>(POSIX.1 says &ldquo;STREAM ioctl(2) timeout&rdquo;.)</p><p>ETIMEDOUT
Connection timed out (POSIX.1-2001).</p><p>ETOOMANYREFS
Too many references: cannot splice.</p><p>ETXTBSY
Text file busy (POSIX.1-2001).</p><p>EUCLEAN
Structure needs cleaning.</p><p>EUNATCH
Protocol driver not attached.</p><p>EUSERS Too many users.</p><p>EWOULDBLOCK
Operation would block (may be same value as EAGAIN)<br>(POSIX.1-2001).</p><p>EXDEV Improper link (POSIX.1-2001).</p><p>EXFULL Exchange full.</p><h2 id=특이-사항>특이 사항</h2><p>많이 하는 실수</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (somecall() <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;somecall() failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>); 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>==</span> ...) {...}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>somecall()</em> 함수의 리턴값이 이미 존재하므로 <em>errno</em>는 더 이상 소용이 없다. (예: 이미 <a href>printf(3)</a>이 호출되는 시점에 값이 바뀌었을수 있다) 만약 <em>somecall()</em> 호출의 결과로서 <em>errno</em>의 값이 보존되기를 원한다면, 다음과 같이 처리해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (somecall() <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> errsv <span style=color:#f92672>=</span> errno; 
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;somecall() failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (errsv <span style=color:#f92672>==</span> ...) {...}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>POSIX 스레드 API는 에러 발생시 <em>errno</em>에 값을 설정하지 않는다. 대신 호출 실패가 발생하면 함수 수행의 리턴값으로 에러 코드를 리턴한다. 이떄 리턴하는 에러 번호는 <em>errno</em>에서 사용되는 것과 동일한 의미를 가진다.</p><p>아주 오래된 일부 시스템에서는 &lt;errno.h>에 <em>errno</em>가 선언되어 있지 않을수도 있다. 이 경우에는 <em>errno</em>를 직접 선언해 주어야 했던 시절이 있다. (예 extern int errno) <em>하지만 절대 이렇게 하지 마라</em> 예전에는 필수적이었을지 모르나, 최근의 C 라이브러리에서는 문제가 발생할 수 있기 때문이다.</p><h2 id=같이-보기>같이 보기</h2><p><em>errno(1)</em>, <a href=https://man7.org/linux/man-pages/man3/err.3.html>err(3)</a>, <a href=https://man7.org/linux/man-pages/man3/error.3.html>error(3)</a>, <a href=https://man7.org/linux/man-pages/man3/perror.3.html>perror(3)</a>, <a href=https://man7.org/linux/man-pages/man3/strerror.3.html>strerror(3)</a></p><h2 id=colophon>COLOPHON</h2><p>이 페이지는 리눅스 매뉴얼 페이지 프로젝트 5.11 릴리즈의 일부이다. 프로젝트의 상세 설명, 버그 리포트 및 본 페이지의 최신 버전에 대한 정보는 다음의 링크에서 확인할 수 있다.<br><a href=https://www.kernel.org/doc/man-pages/.>https://www.kernel.org/doc/man-pages/</a></p><div class=footer></div><a href=about/>About this blog</a><br>Younjin JEONG: <a href="mailto: younjin.jeong@gmail.com">younjin.jeong@gmail.com</a><br>Powered by <a href=https://gohugo.io/>Hugo</a> with
<a href=https://github.com/mrmierzejewski/hugo-theme-console/>Console Theme</a>.<br><a href=https://opensource.org/licenses/LGPL-3.0>Terms and Conditions</a></br></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-LF5W12M5RW"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-LF5W12M5RW")</script></div></body></html>